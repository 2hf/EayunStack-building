From e4a04119f3fe4c0a3abde4681ed0a40c454167fb Mon Sep 17 00:00:00 2001
From: huntxu <mhuntxu@gmail.com>
Date: Mon, 1 Jun 2015 16:05:04 +0800
Subject: [PATCH] merge neutron-qos feature

Upstream:
    https://github.com/eayunstack/neutron-qos

Fixes: redmine #3678

Signed-off-by: huntxu <mhuntxu@gmail.com>
---
 etc/neutron/rootwrap.d/qos.filters                 |  12 +
 .../api/rpc/agentnotifiers/qos_rpc_agent_api.py    |  92 ++++
 .../alembic_migrations/eayun_qos_init_ops.py       |  77 +++
 .../db/migration/alembic_migrations/versions/HEAD  |   2 +-
 .../versions/eayun_neutron_qos.py                  |  36 ++
 neutron/db/qos/__init__.py                         |   0
 neutron/db/qos/qos_db.py                           | 534 ++++++++++++++++++
 neutron/db/qos/qos_rpc.py                          | 213 ++++++++
 neutron/extensions/qos.py                          | 492 +++++++++++++++++
 neutron/services/qos/__init__.py                   |   0
 neutron/services/qos/agents/__init__.py            |   0
 neutron/services/qos/agents/qos_agent.py           | 602 +++++++++++++++++++++
 neutron/services/qos/qos_plugin.py                 |  37 ++
 setup.cfg                                          |   2 +
 14 files changed, 2098 insertions(+), 1 deletion(-)
 create mode 100644 etc/neutron/rootwrap.d/qos.filters
 create mode 100644 neutron/api/rpc/agentnotifiers/qos_rpc_agent_api.py
 create mode 100644 neutron/db/migration/alembic_migrations/eayun_qos_init_ops.py
 create mode 100644 neutron/db/migration/alembic_migrations/versions/eayun_neutron_qos.py
 create mode 100644 neutron/db/qos/__init__.py
 create mode 100644 neutron/db/qos/qos_db.py
 create mode 100644 neutron/db/qos/qos_rpc.py
 create mode 100644 neutron/extensions/qos.py
 create mode 100644 neutron/services/qos/__init__.py
 create mode 100644 neutron/services/qos/agents/__init__.py
 create mode 100644 neutron/services/qos/agents/qos_agent.py
 create mode 100644 neutron/services/qos/qos_plugin.py

diff --git a/etc/neutron/rootwrap.d/qos.filters b/etc/neutron/rootwrap.d/qos.filters
new file mode 100644
index 0000000..ec11fee
--- /dev/null
+++ b/etc/neutron/rootwrap.d/qos.filters
@@ -0,0 +1,12 @@
+# neutron-rootwrap command filters for nodes on which neutron is
+# expected to control network
+#
+# This file should be owned by (and only-writeable by) the root user
+
+# format seems to be
+# cmd-name: filter-name, raw-command, user, args
+
+[Filters]
+
+# qos-agent
+tc: CommandFilter, tc, root
diff --git a/neutron/api/rpc/agentnotifiers/qos_rpc_agent_api.py b/neutron/api/rpc/agentnotifiers/qos_rpc_agent_api.py
new file mode 100644
index 0000000..6c3feb5
--- /dev/null
+++ b/neutron/api/rpc/agentnotifiers/qos_rpc_agent_api.py
@@ -0,0 +1,92 @@
+# Copyright (c) 2015 Eayun, Inc.
+# All rights reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+from oslo import messaging
+
+from neutron.common import rpc as n_rpc
+from neutron.openstack.common import log as logging
+
+LOG = logging.getLogger(__name__)
+
+QOS_AGENT = 'qos_agent'
+QOS_PLUGIN = 'qos_plugin'
+
+
+class QosAgentNotifyAPI(object):
+    """ API for plugin to notify qos agent. """
+
+    def __init__(self, topic=QOS_AGENT):
+        self.topic = topic
+        target = messaging.Target(topic=topic, version='1.0')
+        self.client = n_rpc.get_client(target)
+
+    def _notification(self, context, method, payload, host):
+        if host:
+            LOG.debug('Notify qos agent at %(topic)s.%(host)s '
+                      'the message %(method)s',
+                      {'topic': self.topic, 'host': host, 'method': method})
+            cctxt = self.client.prepare(server=host)
+            cctxt.cast(context, method, payload=payload)
+        else:
+            LOG.debug('Not notify qos agent at %(topic)s '
+                      'the message %(method)s '
+                      'due to no target host',
+                      {'topic': self.topic, 'method': method})
+
+    def qos_created(self, context, qos, host):
+        self._notification(context, 'qos_created', qos, host)
+
+    def qos_updated(self, context, qos, host):
+        self._notification(context, 'qos_updated', qos, host)
+
+    def qos_moved(self, context, qos, host):
+        self._notification(context, 'qos_moved', qos, host)
+
+    def qos_deleted(self, context, id, host):
+        self._notification(context, 'qos_deleted', id, host)
+
+    def qos_queue_created(self, context, qos_queue, host):
+        self._notification(context, 'qos_queue_created', qos_queue, host)
+
+    def qos_queue_updated(self, context, qos_queue, host):
+        self._notification(context, 'qos_queue_updated', qos_queue, host)
+
+    def qos_queue_deleted(self, context, id, host):
+        self._notification(context, 'qos_queue_deleted', id, host)
+
+    def qos_filter_created(self, context, qos_filter, host):
+        self._notification(context, 'qos_filter_created', qos_filter, host)
+
+    def qos_filter_updated(self, context, qos_filter, host):
+        self._notification(context, 'qos_filter_updated', qos_filter, host)
+
+    def qos_filter_deleted(self, context, id, host):
+        self._notification(context, 'qos_filter_deleted', id, host)
+
+
+class QosPluginRpc(object):
+
+    def __init__(self, host):
+        super(QosPluginRpc, self).__init__()
+        target = messaging.Target(topic=QOS_PLUGIN, version='1.0')
+        self.client = n_rpc.get_client(target)
+
+    def _sync_qos(self, context, qos_list):
+        try:
+            cctxt = self.client.prepare()
+            return cctxt.call(
+                context, 'sync_qos', host=self.host, qos_list=qos_list)
+        except Exception:
+            LOG.exception('Failed to sync qos.')
diff --git a/neutron/db/migration/alembic_migrations/eayun_qos_init_ops.py b/neutron/db/migration/alembic_migrations/eayun_qos_init_ops.py
new file mode 100644
index 0000000..f05d549
--- /dev/null
+++ b/neutron/db/migration/alembic_migrations/eayun_qos_init_ops.py
@@ -0,0 +1,77 @@
+# Copyright (c) 2015 Eayun, Inc.
+# All rights reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+from alembic import op
+import sqlalchemy as sa
+
+
+directions = sa.Enum('ingress', 'egress', name='qoss_direction')
+
+
+def upgrade():
+    op.create_table(
+        'eayun_qoss',
+        sa.Column('id', sa.String(length=36), nullable=False),
+        sa.Column('tenant_id', sa.String(length=255), nullable=True),
+        sa.Column('name', sa.String(length=255), nullable=True),
+        sa.Column('description', sa.String(length=255), nullable=True),
+        sa.Column('direction', directions, nullable=False),
+        sa.Column('port_id', sa.String(length=36), nullable=True),
+        sa.Column('router_id', sa.String(length=36), nullable=True),
+        sa.Column('rate', sa.BigInteger(), nullable=False),
+        sa.Column('burst', sa.BigInteger(), nullable=True),
+        sa.Column('cburst', sa.BigInteger(), nullable=True),
+        sa.Column('default_queue_id', sa.String(length=36), nullable=True),
+        sa.ForeignKeyConstraint(['port_id'], ['ports.id']),
+        sa.ForeignKeyConstraint(['router_id'], ['routers.id']),
+        sa.PrimaryKeyConstraint('id')
+    )
+    op.create_table(
+        'eayun_qosqueues',
+        sa.Column('id', sa.String(length=36), nullable=False),
+        sa.Column('tenant_id', sa.String(length=255), nullable=True),
+        sa.Column('qos_id', sa.String(length=36), nullable=False),
+        sa.Column('parent_id', sa.String(length=36), nullable=True),
+        sa.Column('prio', sa.Integer(), nullable=True),
+        sa.Column('rate', sa.BigInteger(), nullable=False),
+        sa.Column('ceil', sa.BigInteger(), nullable=True),
+        sa.Column('burst', sa.BigInteger(), nullable=True),
+        sa.Column('cburst', sa.BigInteger(), nullable=True),
+        sa.ForeignKeyConstraint(['qos_id'], ['eayun_qoss.id']),
+        sa.PrimaryKeyConstraint('id')
+    )
+    op.create_table(
+        'eayun_qosfilters',
+        sa.Column('id', sa.String(length=36), nullable=False),
+        sa.Column('tenant_id', sa.String(length=255), nullable=True),
+        sa.Column('qos_id', sa.String(length=36), nullable=False),
+        sa.Column('queue_id', sa.String(length=36), nullable=True),
+        sa.Column('prio', sa.Integer(), nullable=False, unique=True),
+        sa.Column('protocol', sa.Integer(), nullable=True),
+        sa.Column('src_port', sa.Integer(), nullable=True),
+        sa.Column('dst_port', sa.Integer(), nullable=True),
+        sa.Column('src_addr', sa.String(length=255), nullable=True),
+        sa.Column('dst_addr', sa.String(length=255), nullable=True),
+        sa.Column('custom_match', sa.String(length=255), nullable=True),
+        sa.ForeignKeyConstraint(['qos_id'], ['eayun_qoss.id']),
+        sa.ForeignKeyConstraint(['queue_id'], ['eayun_qosqueues.id']),
+        sa.PrimaryKeyConstraint('id')
+    )
+
+
+def downgrade():
+    op.drop_table('eayun_qosfilters')
+    op.drop_table('eayun_qosqueues')
+    op.drop_table('eayun_qoss')
diff --git a/neutron/db/migration/alembic_migrations/versions/HEAD b/neutron/db/migration/alembic_migrations/versions/HEAD
index 7a30775..21f478f 100644
--- a/neutron/db/migration/alembic_migrations/versions/HEAD
+++ b/neutron/db/migration/alembic_migrations/versions/HEAD
@@ -1 +1 @@
-juno
+eayun_neutron_qos
diff --git a/neutron/db/migration/alembic_migrations/versions/eayun_neutron_qos.py b/neutron/db/migration/alembic_migrations/versions/eayun_neutron_qos.py
new file mode 100644
index 0000000..2368e26
--- /dev/null
+++ b/neutron/db/migration/alembic_migrations/versions/eayun_neutron_qos.py
@@ -0,0 +1,36 @@
+# Copyright 2015 OpenStack Foundation
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+#
+
+"""eayun_neutron_qos
+
+Revision ID: eayun_neutron_qos
+Revises: juno
+Create Date: 2015-05-04 06:36:43.672556
+
+"""
+from neutron.db.migration.alembic_migrations import eayun_qos_init_ops
+
+
+# revision identifiers, used by Alembic.
+revision = 'eayun_neutron_qos'
+down_revision = 'juno'
+
+
+def upgrade():
+    eayun_qos_init_ops.upgrade()
+
+
+def downgrade():
+    eayun_qos_init_ops.downgrade()
diff --git a/neutron/db/qos/__init__.py b/neutron/db/qos/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/neutron/db/qos/qos_db.py b/neutron/db/qos/qos_db.py
new file mode 100644
index 0000000..49ef0c1
--- /dev/null
+++ b/neutron/db/qos/qos_db.py
@@ -0,0 +1,534 @@
+# Copyright (c) 2015 Eayun, Inc.
+# All rights reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+import sqlalchemy as sa
+from sqlalchemy import orm
+from sqlalchemy.orm import exc
+
+from neutron.db import model_base
+from neutron.db import models_v2
+from neutron.db import common_db_mixin as base_db
+from neutron.db import l3_db
+from neutron.extensions import qos as ext_qos
+from neutron.openstack.common import uuidutils
+from neutron.openstack.common import log as logging
+
+LOG = logging.getLogger(__name__)
+
+
+class Qos(model_base.BASEV2, models_v2.HasId, models_v2.HasTenant):
+    __tablename__ = 'eayun_qoss'
+
+    name = sa.Column(sa.String(255))
+    description = sa.Column(sa.String(255))
+    direction = sa.Column(sa.Enum('ingress', 'egress', name='qoss_direction'),
+                          nullable=False)
+    port_id = sa.Column(sa.String(36), sa.ForeignKey('ports.id'))
+    router_id = sa.Column(sa.String(36), sa.ForeignKey('routers.id'))
+    rate = sa.Column(sa.BigInteger, nullable=False)
+    burst = sa.Column(sa.BigInteger)
+    cburst = sa.Column(sa.BigInteger)
+    default_queue_id = sa.Column(sa.String(36),
+                                 sa.ForeignKey('eayun_qosqueues.id'))
+    port = orm.relationship(
+        models_v2.Port,
+        backref=orm.backref(
+            'eayun_qoss', cascade='all,delete', lazy='joined', uselist=True),
+        primaryjoin='Port.id==Qos.port_id')
+    router = orm.relationship(
+        l3_db.Router,
+        backref=orm.backref(
+            'eayun_qoss', cascade='all,delete', lazy='joined', uselist=True),
+        primaryjoin='Router.id==Qos.router_id')
+    default_queue = orm.relationship(
+        "QosQueue",
+        primaryjoin='QosQueue.id==Qos.default_queue_id', post_update=True)
+
+
+class QosQueue(model_base.BASEV2, models_v2.HasId, models_v2.HasTenant):
+    __tablename__ = 'eayun_qosqueues'
+
+    qos_id = sa.Column(sa.String(36),
+                       sa.ForeignKey('eayun_qoss.id'),
+                       nullable=False)
+    parent_id = sa.Column(sa.String(36),
+                          sa.ForeignKey('eayun_qosqueues.id'))
+    prio = sa.Column(sa.Integer)
+    rate = sa.Column(sa.BigInteger, nullable=False)
+    ceil = sa.Column(sa.BigInteger)
+    burst = sa.Column(sa.BigInteger)
+    cburst = sa.Column(sa.BigInteger)
+    qos = orm.relationship(
+        Qos,
+        backref=orm.backref(
+            'queues', cascade='all,delete', lazy='joined', uselist=True),
+        primaryjoin='Qos.id==QosQueue.qos_id')
+    parent_queue = orm.relationship(
+        "QosQueue",
+        remote_side='QosQueue.id',
+        backref=orm.backref(
+            'subqueues', cascade='all,delete', lazy='joined', uselist=True),
+        primaryjoin='QosQueue.id==QosQueue.parent_id')
+
+
+class QosFilter(model_base.BASEV2, models_v2.HasId, models_v2.HasTenant):
+    __tablename__ = 'eayun_qosfilters'
+
+    qos_id = sa.Column(sa.String(36),
+                       sa.ForeignKey('eayun_qoss.id', ondelete='CASCADE'),
+                       nullable=False)
+    queue_id = sa.Column(sa.String(36),
+                         sa.ForeignKey('eayun_qosqueues.id'))
+    prio = sa.Column(sa.Integer, nullable=False, unique=True)
+    protocol = sa.Column(sa.Integer)
+    src_port = sa.Column(sa.Integer)
+    dst_port = sa.Column(sa.Integer)
+    src_addr = sa.Column(sa.String(255))
+    dst_addr = sa.Column(sa.String(255))
+    custom_match = sa.Column(sa.String(255))
+    qos = orm.relationship(
+        Qos,
+        backref=orm.backref(
+            'filters', cascade='all,delete', lazy='joined', uselist=True),
+        primaryjoin='Qos.id==QosFilter.qos_id')
+    queue = orm.relationship(
+        QosQueue,
+        backref=orm.backref(
+            'attached_filters', cascade='all,delete', lazy='joined',
+            uselist=True),
+        primaryjoin='QosQueue.id==QosFilter.queue_id')
+
+
+class QosDbMixin(ext_qos.QosPluginBase, base_db.CommonDbMixin):
+    """ Mixin class to add security group to db_base_plugin_v2. """
+
+    __native_bulk_support = True
+
+    def _get_qos(self, context, id):
+        try:
+            query = self._model_query(context, Qos)
+            qos = query.filter(Qos.id == id).one()
+        except exc.NoResultFound:
+            raise ext_qos.QosNotFound(id=id)
+        return qos
+
+    def _get_qos_siblings(self, context, router_id, port_id):
+        if router_id:
+            return self._model_query(
+                context, Qos).filter(Qos.router_id == router_id).all()
+        elif port_id:
+            return self._model_query(
+                context, Qos).filter(Qos.port_id == port_id).all()
+        else:
+            return []
+
+    def _parse_qos_input(self, qos_input):
+        qos = qos_input['qos']
+        queue = dict()
+
+        if 'rate' in qos:
+            queue['ceil'] = qos.get('rate')
+
+        if 'default_rate' in qos:
+            queue['rate'] = qos.pop('default_rate')
+
+        if 'default_burst' in qos:
+            queue['burst'] = qos.pop('default_burst')
+
+        if 'default_cburst' in qos:
+            queue['cburst'] = qos.pop('default_cburst')
+
+        if 'target_type' not in qos and 'target_id' not in qos:
+            pass
+        else:
+            target_type = qos.pop('target_type')
+            target_id = qos.pop('target_id')
+
+            qos['port_id'] = qos['router_id'] = None
+            if (target_type is not None and target_id is not None):
+                if target_type == 'router':
+                    qos['router_id'] = target_id
+                elif target_type == 'port':
+                    qos['port_id'] = target_id
+
+        return qos, queue
+
+    def _make_qos_dict(self, qos, fields=None):
+        res = {'id': qos.id,
+               'tenant_id': qos.tenant_id,
+               'name': qos.name,
+               'description': qos.description,
+               'direction': qos.direction,
+               'rate': qos.rate,
+               'burst': qos.burst,
+               'cburst': qos.cburst,
+               'default_queue_id': qos.default_queue_id}
+
+        if qos.port_id is not None:
+            res.update({'target_type': 'port',
+                        'target_id': qos.port_id})
+        elif qos.router_id is not None:
+            res.update({'target_type': 'router',
+                        'target_id': qos.router_id})
+        else:
+            res.update({'target_type': None, 'target_id': None})
+
+        res['qos_queues'] = [
+            self._make_qos_queue_dict(q) for q in
+            filter(lambda q: q.parent_queue is None, qos.queues)
+        ]
+
+        res['unattached_filters'] = [
+            self._make_qos_filter_dict(f) for f in
+            filter(lambda f: f.queue is None, qos.filters)
+        ]
+
+        return self._fields(res, fields)
+
+    def _aggregate_rate_of_qos(self, qos):
+        return reduce(lambda x, y: x + y, [q.rate for q in qos.queues])
+
+    def _check_qos_rate(self, qos, delta, maximum=None):
+        if maximum is None:
+            if delta <= 0:
+                return
+            else:
+                maximum = qos.rate
+        if self._aggregate_rate_of_qos(qos) + delta > maximum:
+            raise ext_qos.QosRateTooSmall(id=qos.id, rate=maximum)
+
+    def create_qos_bulk(self, context, qos):
+        return self._create_bulk('qos', context, qos)
+
+    def create_qos(self, context, qos):
+        """ Create a qos and its default queue. """
+        qos, queue = self._parse_qos_input(qos)
+        tenant_id = self._get_tenant_id_for_create(context, qos)
+
+        qos_id = qos.get('id') or uuidutils.generate_uuid()
+        default_queue_id = uuidutils.generate_uuid()
+
+        if qos['rate'] < queue['rate']:
+            raise ext_qos.QosRateTooSmall(id=qos_id, rate=qos['rate'])
+
+        if qos['router_id']:
+            self._check_router(context, qos['router_id'])
+        elif qos['port_id']:
+            self._check_port(context, qos['port_id'])
+
+        siblings = self._get_qos_siblings(
+            context,
+            qos['router_id'],
+            qos['port_id'])
+        if len(siblings) > 1:
+            raise ext_qos.QosConflict()
+        elif len(siblings) > 0:
+            if siblings[0].direction == qos['direction']:
+                raise ext_qos.QosConflict()
+
+        with context.session.begin(subtransactions=True):
+            qos_db = Qos(
+                id=qos_id, tenant_id=tenant_id,
+                name=qos['name'], description=qos['description'],
+                direction=qos['direction'],
+                port_id=qos['port_id'], router_id=qos['router_id'],
+                rate=qos['rate'], burst=qos['burst'], cburst=qos['cburst'],
+                default_queue_id=default_queue_id)
+            qos_queue_db = QosQueue(
+                id=default_queue_id, tenant_id=tenant_id,
+                qos_id=qos_id, parent_id=None, prio=7,
+                rate=queue['rate'], ceil=queue['ceil'],
+                burst=queue['burst'], cburst=queue['cburst'])
+            context.session.add(qos_db)
+            context.session.add(qos_queue_db)
+
+        return self._make_qos_dict(qos_db)
+
+    def update_qos(self, context, id, qos):
+        qos, queue = self._parse_qos_input(qos)
+
+        router_id = qos.get('router_id', None)
+        port_id = qos.get('port_id', None)
+        if router_id:
+            self._check_router(context, router_id)
+        elif port_id:
+            self._check_port(context, port_id)
+
+        with context.session.begin(subtransactions=True):
+            qos_db = self._get_qos(context, id)
+            qos_queue_db = self._get_qos_queue(context,
+                                               qos_db.default_queue_id)
+
+            new_rate = qos.get('rate', qos_db.rate)
+            new_queue_rate = queue.get('rate', qos_queue_db.rate)
+            rate_delta = new_queue_rate - qos_queue_db.rate
+            self._check_qos_rate(qos_db, rate_delta, new_rate)
+
+            siblings = self._get_qos_siblings(context, router_id, port_id)
+            # In case original target_id was specified when update
+            siblings = filter(lambda s: s.id != qos_db.id, siblings)
+            if len(siblings) > 1:
+                raise ext_qos.QosConflict()
+            elif len(siblings) > 0:
+                if siblings[0].direction == qos_db.direction:
+                    raise ext_qos.QosConflict()
+
+            qos_db.update(qos)
+            if queue:
+                qos_queue_db.update(queue)
+
+        return self._make_qos_dict(qos_db)
+
+    def delete_qos(self, context, id):
+        qos = self._get_qos(context, id)
+        with context.session.begin(subtransactions=True):
+            context.session.delete(qos)
+
+    def get_qoss(self, context, filters=None, fields=None,
+                 sorts=None, limit=None, marker=None,
+                 page_reverse=False):
+        marker_obj = self._get_marker_obj(context, 'qos', limit, marker)
+        return self._get_collection(
+            context, Qos, self._make_qos_dict,
+            filters=filters, fields=fields, sorts=sorts,
+            limit=limit, marker_obj=marker_obj, page_reverse=page_reverse)
+
+    def get_qoss_count(self, context, filters=None):
+        return self._get_collection_count(context, Qos, filters=filters)
+
+    def get_qos(self, context, id, fields=None, tenant_id=None):
+        if tenant_id:
+            tmp_tenant_id = context.tenant_id
+            context.tenant_id = tenant_id
+
+        try:
+            with context.session.begin(subtransactions=True):
+                ret = self._make_qos_dict(self._get_qos(context, id), fields)
+        finally:
+            if tenant_id:
+                context.tenant_id = tmp_tenant_id
+        return ret
+
+    def _get_qos_queue(self, context, id):
+        try:
+            query = self._model_query(context, QosQueue)
+            qos_queue = query.filter(QosQueue.id == id).one()
+        except exc.NoResultFound:
+            raise ext_qos.QosQueueNotFound(id=id)
+        return qos_queue
+
+    def _make_qos_queue_dict(self, qos_queue, fields=None):
+        res = {'id': qos_queue.id,
+               'tenant_id': qos_queue.tenant_id,
+               'qos_id': qos_queue.qos_id,
+               'parent_id': qos_queue.parent_id,
+               'prio': qos_queue.prio,
+               'rate': qos_queue.rate,
+               'ceil': qos_queue.ceil,
+               'burst': qos_queue.burst,
+               'cburst': qos_queue.cburst}
+
+        res['subqueues'] = [self._make_qos_queue_dict(q)
+                            for q in qos_queue.subqueues]
+        res['attached_filters'] = [self._make_qos_filter_dict(f)
+                                   for f in qos_queue.attached_filters]
+
+        return self._fields(res, fields)
+
+    def _aggregate_rate_of_qos_queue(self, qos_queue):
+        if qos_queue.subqueues:
+            return reduce(
+                lambda x, y: x + y, [q.rate for q in qos_queue.subqueues])
+        else:
+            return 0
+
+    def _check_qos_queue_rate(self, qos_queue, delta, maximum=None):
+        if maximum is None:
+            if delta <= 0:
+                return
+            else:
+                maximum = qos_queue.rate
+        if self._aggregate_rate_of_qos_queue(qos_queue) + delta > maximum:
+            raise ext_qos.QosQueueRateTooSmall(id=qos_queue.id, rate=maximum)
+
+    def _check_queue_in_qos(self, qos_id, qos_queue):
+        if qos_id != qos_queue.qos_id:
+            raise ext_qos.QosQueueNotInQos(
+                qos_id=qos_id,
+                qos_queue_id=qos_queue.qos_id
+            )
+
+    def create_qos_queue_bulk(self, context, qos_queue):
+        return self._create_bulk('qos_queue', context, qos_queue)
+
+    def create_qos_queue(self, context, qos_queue):
+        qos_queue = qos_queue['qos_queue']
+
+        qos_db = self._get_qos(context, qos_queue['qos_id'])
+        self._check_qos_rate(qos_db, qos_queue['rate'])
+        if qos_queue['parent_id'] is not None:
+            parent_queue_db = self._get_qos_queue(context,
+                                                  qos_queue['parent_id'])
+            if parent_queue_db.attached_filters:
+                raise ext_qos.QosParentQueueInUse(parent_id=parent_queue_db.id)
+            self._check_queue_in_qos(qos_db.id, parent_queue_db)
+            self._check_qos_queue_rate(parent_queue_db, qos_queue['rate'])
+        tenant_id = self._get_tenant_id_for_create(context, qos_queue)
+        qos_queue_id = qos_queue.get('id') or uuidutils.generate_uuid()
+        with context.session.begin(subtransactions=True):
+            qos_queue_db = QosQueue(
+                id=qos_queue_id, tenant_id=tenant_id,
+                qos_id=qos_queue['qos_id'], parent_id=qos_queue['parent_id'],
+                prio=qos_queue['prio'],
+                rate=qos_queue['rate'], ceil=qos_queue['ceil'],
+                burst=qos_queue['burst'], cburst=qos_queue['cburst'])
+            context.session.add(qos_queue_db)
+
+        return self._make_qos_queue_dict(qos_queue_db)
+
+    def update_qos_queue(self, context, id, qos_queue):
+        qos_queue = qos_queue['qos_queue']
+
+        with context.session.begin(subtransactions=True):
+            qos_queue_db = self._get_qos_queue(context, id)
+            if id == qos_queue_db.qos.default_queue_id:
+                raise ext_qos.QosQueueCannotEditDefault(
+                    qos_id=qos_queue_db.qos_id,
+                    qos_queue_id=id)
+            new_rate = qos_queue.get('rate', qos_queue_db.rate)
+            rate_delta = new_rate - qos_queue_db.rate
+            self._check_qos_rate(qos_queue_db.qos, rate_delta)
+            if qos_queue_db.parent_queue:
+                self._check_qos_queue_rate(qos_queue_db.parent_queue,
+                                           rate_delta)
+            if qos_queue_db.subqueues:
+                new_rate = qos_queue.get('rate', qos_queue_db.rate)
+                self._check_qos_queue_rate(qos_queue_db, 0, new_rate)
+            qos_queue_db.update(qos_queue)
+        return self._make_qos_queue_dict(qos_queue_db)
+
+    def delete_qos_queue(self, context, id):
+        qos_queue = self._get_qos_queue(context, id)
+        if id == qos_queue.qos.default_queue_id:
+            raise ext_qos.QosQueueCannotEditDefault(
+                qos_id=qos_queue.qos_id,
+                qos_queue_id=id)
+        with context.session.begin(subtransactions=True):
+            context.session.delete(qos_queue)
+
+    def get_qos_queues(self, context, filters=None, fields=None,
+                       sorts=None, limit=None, marker=None,
+                       page_reverse=False):
+        marker_obj = self._get_marker_obj(context, 'qos_queue', limit, marker)
+        return self._get_collection(
+            context, QosQueue, self._make_qos_queue_dict,
+            filters=filters, fields=fields, sorts=sorts,
+            limit=limit, marker_obj=marker_obj, page_reverse=page_reverse)
+
+    def get_qos_queues_count(self, context, filters=None):
+        return self._get_collection_count(context, QosQueue, filters=filters)
+
+    def get_qos_queue(self, context, id, fields=None):
+        qos_queue = self._get_qos_queue(context, id)
+        return self._make_qos_queue_dict(qos_queue, fields)
+
+    def _get_qos_filter(self, context, id):
+        try:
+            query = self._model_query(context, QosFilter)
+            qos_filter = query.filter(QosFilter.id == id).one()
+        except exc.NoResultFound:
+            raise ext_qos.QosFilterNotFound(id=id)
+        return qos_filter
+
+    def _make_qos_filter_dict(self, qos_filter, fields=None):
+        res = {'id': qos_filter.id,
+               'tenant_id': qos_filter.tenant_id,
+               'qos_id': qos_filter.qos_id,
+               'queue_id': qos_filter.queue_id,
+               'prio': qos_filter.prio,
+               'protocol': qos_filter.protocol,
+               'src_port': qos_filter.src_port,
+               'dst_port': qos_filter.dst_port,
+               'src_addr': qos_filter.src_addr,
+               'dst_addr': qos_filter.dst_addr}
+
+        if qos_filter.custom_match is not None:
+            res.update({'custom_match': qos_filter.custom_match})
+
+        return self._fields(res, fields)
+
+    def create_qos_filter_bulk(self, context, qos_filter):
+        return self._create_bulk('qos_filter', context, qos_filter)
+
+    def create_qos_filter(self, context, qos_filter):
+        qos_filter = qos_filter['qos_filter']
+
+        qos_db = self._get_qos(context, qos_filter['qos_id'])
+        if qos_filter['queue_id'] is not None:
+            qos_queue_db = self._get_qos_queue(context, qos_filter['queue_id'])
+            self._check_queue_in_qos(qos_db.id, qos_queue_db)
+            if qos_queue_db.subqueues:
+                raise ext_qos.QosQueueHasSub(qos_queue_id=qos_queue_db.id)
+        tenant_id = self._get_tenant_id_for_create(context, qos_filter)
+        qos_filter_id = qos_filter.get('id') or uuidutils.generate_uuid()
+        with context.session.begin(subtransactions=True):
+            qos_filter_db = QosFilter(
+                id=qos_filter_id, tenant_id=tenant_id,
+                qos_id=qos_filter['qos_id'], queue_id=qos_filter['queue_id'],
+                prio=qos_filter['prio'],
+                protocol=qos_filter['protocol'],
+                src_port=qos_filter['src_port'],
+                dst_port=qos_filter['dst_port'],
+                src_addr=qos_filter['src_addr'],
+                dst_addr=qos_filter['dst_addr'],
+                custom_match=qos_filter['custom_match'])
+            context.session.add(qos_filter_db)
+
+        return self._make_qos_filter_dict(qos_filter_db)
+
+    def update_qos_filter(self, context, id, qos_filter):
+        qos_filter = qos_filter['qos_filter']
+
+        with context.session.begin(subtransactions=True):
+            qos_filter_db = self._get_qos_filter(context, id)
+            if qos_filter.get('queue_id', None) is not None:
+                qos_queue_db = self._get_qos_queue(context,
+                                                   qos_filter['queue_id'])
+                self._check_queue_in_qos(qos_filter_db.qos_id, qos_queue_db)
+                if qos_queue_db.subqueues:
+                    raise ext_qos.QosQueueHasSub(qos_queue_id=qos_queue_db.id)
+            qos_filter_db.update(qos_filter)
+        return self._make_qos_filter_dict(qos_filter_db)
+
+    def delete_qos_filter(self,  context, id):
+        qos_filter = self._get_qos_filter(context, id)
+        with context.session.begin(subtransactions=True):
+            context.session.delete(qos_filter)
+
+    def get_qos_filters(self, context, filters=None, fields=None,
+                        sorts=None, limit=None, marker=None,
+                        page_reverse=False):
+        marker_obj = self._get_marker_obj(context, 'qos_filter', limit, marker)
+        return self._get_collection(
+            context, QosFilter, self._make_qos_filter_dict,
+            filters=filters, fields=fields, sorts=sorts,
+            limit=limit, marker_obj=marker_obj, page_reverse=page_reverse)
+
+    def get_qos_filters_count(self, context, filters=None):
+        return self._get_collection_count(context, QosFilter, filters=filters)
+
+    def get_qos_filter(self, context, id, fields=None):
+        qos_filter = self._get_qos_filter(context, id)
+        return self._make_qos_filter_dict(qos_filter, fields)
diff --git a/neutron/db/qos/qos_rpc.py b/neutron/db/qos/qos_rpc.py
new file mode 100644
index 0000000..bb723a2
--- /dev/null
+++ b/neutron/db/qos/qos_rpc.py
@@ -0,0 +1,213 @@
+# Copyright (c) 2015 Eayun, Inc.
+# All rights reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+from oslo import messaging
+
+from neutron.db.qos import qos_db
+from neutron import manager
+from neutron.extensions import qos as ext_qos
+from neutron.openstack.common import log as logging
+from neutron.plugins.common import constants as service_constants
+from neutron.plugins.ml2 import db  # hacky
+
+LOG = logging.getLogger(__name__)
+
+NIC_NAME_LEN = 14
+
+
+class QosServerRpcServerMixin(qos_db.QosDbMixin):
+
+    def _get_host_from_qos_id(self, context, qos_id):
+        qos = self._get_qos(context, qos_id)
+        if qos['router_id'] is not None:
+            plugin = manager.NeutronManager.get_service_plugins().get(
+                service_constants.L3_ROUTER_NAT)
+            adminContext = context if context.is_admin else context.elevated()
+            l3_agents = plugin.get_l3_agents_hosting_routers(
+                adminContext, [qos['router_id']],
+                admin_state_up=True, active=True)
+            return l3_agents[0].host
+        elif qos['port_id'] is not None:
+            """
+            plugin = manager.NeutronManager.get_plugin()
+            adminContext = context if context.is_admin else context.elevated()
+            return plugin.get_port_binding_host(adminContext, qos['port_id'])
+            """
+            return db.get_port_binding_host(qos['port_id'])
+        else:
+            return None
+
+    def _get_qos_on_host(self, context, host):
+        hosting_qos = dict()
+        for qos in self.get_qoss(context):
+            if host == self._get_host_from_qos_id(context, qos['id']):
+                qos.pop('unattached_filters')
+                qos.update(
+                    {'devices': self._get_qos_devices(context, qos['id'])})
+                hosting_qos[qos['id']] = qos
+
+        return hosting_qos
+
+    def _get_qos_devices(self, context, qos_id):
+        ret = []
+        qos_db = self._get_qos(context, qos_id)
+        if qos_db.router_id is not None:
+            plugin = manager.NeutronManager.get_service_plugins().get(
+                service_constants.L3_ROUTER_NAT)
+            adminContext = context if context.is_admin else context.elevated()
+            # A bit hacky here
+            router = plugin._get_router(adminContext, qos_db.router_id)
+            if qos_db.direction == 'egress':
+                if router.gw_port_id:
+                    ret.append(("qg-%s" % router.gw_port_id)[:NIC_NAME_LEN])
+            else:
+                for rp in router.attached_ports:
+                    if rp.port_id != router.gw_port_id:
+                        ret.append(("qr-%s" % rp.port_id)[:NIC_NAME_LEN])
+        elif qos_db.port_id is not None:
+            prefix = 'qvo' if qos_db.direction == 'ingress' else 'qvb'
+            ret.append(("%s%s" % (prefix, qos_db.port_id))[:NIC_NAME_LEN])
+
+        return ret
+
+    def _check_port(self, context, port_id):
+        plugin = manager.NeutronManager.get_plugin()
+        adminContext = context if context.is_admin else context.elevated()
+        port = plugin.get_port(adminContext, port_id)
+        if not port['device_owner'].startswith('compute'):
+            raise ext_qos.QosInvalidPortType(
+                port_id=port_id, port_type=port['device_owner'])
+
+    def _check_router(self, context, router_id):
+        plugin = manager.NeutronManager.get_service_plugins().get(
+            service_constants.L3_ROUTER_NAT)
+        adminContext = context if context.is_admin else context.elevated()
+        plugin.get_router(adminContext, router_id)
+
+    def sync_qos(self, context, qos_list, host):
+        hosting_qos = self._get_qos_on_host(context, host)
+        deleted_qos = filter(lambda qos: qos not in hosting_qos, qos_list)
+
+        for qos in qos_list:
+            if qos in hosting_qos:
+                hosting_qos.pop(qos)
+
+        return {'deleted': deleted_qos, 'added': hosting_qos.values()}
+
+    def create_qos(self, context, qos):
+        qos = super(
+            QosServerRpcServerMixin, self
+        ).create_qos(context, qos)
+        host = self._get_host_from_qos_id(context, qos['id'])
+        unattached_filters = qos.pop('unattached_filters')
+        qos.update({'devices': self._get_qos_devices(context, qos['id'])})
+        self.notifier.qos_created(context, qos, host)
+        qos.update({'unattached_filters': unattached_filters})
+        qos.pop('devices')
+        return qos
+
+    def update_qos(self, context, id, qos):
+        host_prev = self._get_host_from_qos_id(context, id)
+        qos = super(
+            QosServerRpcServerMixin, self
+        ).update_qos(context, id, qos)
+        host = self._get_host_from_qos_id(context, id)
+        if host_prev != host:
+            # assoicated port or router may be changed
+            self.notifier.qos_moved(context, id, host_prev)
+        unattached_filters = qos.pop('unattached_filters')
+        qos.update({'devices': self._get_qos_devices(context, id)})
+        self.notifier.qos_updated(context, qos, host)
+        qos.update({'unattached_filters': unattached_filters})
+        qos.pop('devices')
+        return qos
+
+    def delete_qos(self, context, id):
+        host = self._get_host_from_qos_id(context, id)
+        super(
+            QosServerRpcServerMixin, self
+        ).delete_qos(context, id)
+        self.notifier.qos_deleted(context, id, host)
+
+    def create_qos_queue(self, context, qos_queue):
+        qos_queue = super(
+            QosServerRpcServerMixin, self
+        ).create_qos_queue(context, qos_queue)
+        host = self._get_host_from_qos_id(context, qos_queue['qos_id'])
+        self.notifier.qos_queue_created(context, qos_queue, host)
+        return qos_queue
+
+    def update_qos_queue(self, context, id, qos_queue):
+        qos_queue = super(
+            QosServerRpcServerMixin, self
+        ).update_qos_queue(context, id, qos_queue)
+        host = self._get_host_from_qos_id(context, qos_queue['qos_id'])
+        self.notifier.qos_queue_updated(context, qos_queue, host)
+        return qos_queue
+
+    def delete_qos_queue(self, context, id):
+        qos_queue = self._get_qos_queue(context, id)
+        host = self._get_host_from_qos_id(context, qos_queue['qos_id'])
+        super(
+            QosServerRpcServerMixin, self
+        ).delete_qos_queue(context, id)
+        self.notifier.qos_queue_deleted(context, id, host)
+
+    def create_qos_filter(self, context, qos_filter):
+        qos_filter = super(
+            QosServerRpcServerMixin, self
+        ).create_qos_filter(context, qos_filter)
+        if qos_filter['queue_id']:
+            host = self._get_host_from_qos_id(context, qos_filter['qos_id'])
+            self.notifier.qos_filter_created(context, qos_filter, host)
+        return qos_filter
+
+    def update_qos_filter(self, context, id, qos_filter):
+        orig_queue_id = self.get_qos_filter(context, id)['queue_id']
+        qos_filter = super(
+            QosServerRpcServerMixin, self
+        ).update_qos_filter(context, id, qos_filter)
+        host = self._get_host_from_qos_id(context, qos_filter['qos_id'])
+        if orig_queue_id is None:
+            if qos_filter['queue_id']:
+                self.notifier.qos_filter_created(context, qos_filter, host)
+        else:
+            if qos_filter['queue_id'] is None:
+                self.notifier.qos_filter_deleted(context, id, host)
+            else:
+                self.notifier.qos_filter_updated(context, qos_filter, host)
+        return qos_filter
+
+    def delete_qos_filter(self, context, id):
+        qos_filter = self.get_qos_filter(context, id)
+        super(
+            QosServerRpcServerMixin, self
+        ).delete_qos_filter(context, id)
+        if qos_filter['queue_id']:
+            host = self._get_host_from_qos_id(context, qos_filter['qos_id'])
+            self.notifier.qos_filter_deleted(context, id, host)
+
+
+class QosRpcCallbacks(object):
+
+    target = messaging.Target(version='1.0')
+
+    def __init__(self, qos_plugin):
+        self.qos_plugin = qos_plugin
+
+    def sync_qos(self, context, **kwargs):
+        qos_list = kwargs.get('qos_list')
+        host = kwargs.get('host')
+        return self.qos_plugin.sync_qos(context, qos_list, host)
diff --git a/neutron/extensions/qos.py b/neutron/extensions/qos.py
new file mode 100644
index 0000000..f967ab8
--- /dev/null
+++ b/neutron/extensions/qos.py
@@ -0,0 +1,492 @@
+# Copyright (c) 2015 Eayun, Inc.
+# All rights reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+import abc
+
+import six
+
+from neutron.api import extensions
+from neutron.api.v2 import attributes as attr
+from neutron.api.v2 import base
+from neutron.api.v2 import resource_helper
+from neutron.common import exceptions as nexception
+from neutron import manager
+from neutron.services import service_base
+
+EAYUN_QOS = "/eayun_qos"
+
+
+class QosInvalidPortType(nexception.InvalidInput):
+    message = _("Cannot create qos under port %(port_id)s, its "
+                "type %(port_type)s is not compute:nova")
+
+
+class QosNotFound(nexception.NotFound):
+    message = _("Qos %(id)s does not exists.")
+
+
+class QosQueueNotFound(nexception.NotFound):
+    message = _("Qos queue %(id)s does not exists.")
+
+
+class QosFilterNotFound(nexception.NotFound):
+    message = _("Qos filter %(id)s does not exists.")
+
+
+class QosConflict(nexception.InvalidInput):
+    message = _("A Qos of the same direction is already set with the target")
+
+
+class QosRateTooSmall(nexception.NeutronException):
+    message = _("Rate %(rate)s of qos %(id)s is too small to afford "
+                "its queues.")
+
+
+class QosQueueRateTooSmall(nexception.NeutronException):
+    message = _("Rate %(rate)s of qos queue %(id)s is too small to afford "
+                "its subqueues.")
+
+
+class QosQueueNotInQos(nexception.NeutronException):
+    message = _("Qos queue %(qos_queue_id)s is not in Qos %(qos_id)s.")
+
+
+class QosQueueCannotEditDefault(nexception.InvalidInput):
+    message = _("Qos queue %(qos_queue_id)s cannot be edited directly. "
+                "It is the default queue of Qos %(qos_id)s.")
+
+
+class QosParentQueueInUse(nexception.InUse):
+    message = _("Cannot create subqueue under parent queue %(parent_id)s, "
+                "it has filters attached.")
+
+
+class QosQueueHasSub(nexception.InUse):
+    message = _("Cannot create filter(s) under parent queue %(qos_queue_id)s, "
+                "it has subqueues.")
+
+
+class QosInvalidRateValue(nexception.InvalidInput):
+    message = _("Invalid value for rate: %(rate)s. "
+                "It must be 1 to 4294967295.")
+
+
+class QosInvalidCeilValue(nexception.InvalidInput):
+    message = _("Invalid value for ceil: %(ceil)s. "
+                "It must be None or between 1 to 4294967295.")
+
+
+class QosInvalidBurstValue(nexception.InvalidInput):
+    message = _("Invalid value for burst: %(burst)s. "
+                "It must be None or between 1 to 4294967295.")
+
+
+class QosInvalidCburstValue(nexception.InvalidInput):
+    message = _("Invalid value for cburst: %(cburst)s. "
+                "It must be None or between 1 to 4294967295.")
+
+
+class QosInvalidQueuePrioValue(nexception.InvalidInput):
+    message = _("Invalid value for queue prio: %(prio)s. "
+                "It must be None or between 0 to 7.")
+
+
+class QosInvalidFilterPrioValue(nexception.InvalidInput):
+    message = _("Invalid value for filter prio: %(prio)s. "
+                "It must be None or between 0 to 4294967295.")
+
+
+class QosInvalidProtocolValue(nexception.InvalidInput):
+    message = _("Invalid value for protocol: %(protocol)s. "
+                "It must be None or between 1 to 255.")
+
+
+class QosInvalidPortValue(nexception.InvalidInput):
+    message = _("Invalid value for port: %(port)s. "
+                "It must be None or between 1 to 65535.")
+
+
+def convert_to_tc_u32(value):
+    """ Callers should at least catch ValueError and TypeError. """
+    u32 = int(value)
+    if not (u32 >= 0 and u32 <= 4294967295):
+        raise ValueError
+
+    return u32
+
+
+def convert_to_tc_not_zero_u32(value):
+    """ Callers should at least catch ValueError and TypeError. """
+    u32 = convert_to_tc_u32(value)
+    if not u32 > 0:
+        raise ValueError
+
+    return u32
+
+
+def convert_to_tc_u32_or_none(value):
+    """ Callers should at least catch ValueError and probably TypeError. """
+    if value is None:
+        ret = value
+    else:
+        ret = convert_to_tc_u32(value)
+
+    return ret
+
+
+def convert_to_tc_not_zero_u32_or_none(value):
+    """ Callers should at least catch ValueError and probably TypeError. """
+    if value is None:
+        ret = value
+    else:
+        ret = convert_to_tc_not_zero_u32(value)
+
+    return ret
+
+
+def convert_to_rate(value):
+    try:
+        return convert_to_tc_not_zero_u32(value)
+    except (ValueError, TypeError):
+        raise QosInvalidRateValue(rate=value)
+
+
+def convert_to_ceil(value):
+    try:
+        return convert_to_tc_not_zero_u32_or_none(value)
+    except (ValueError, TypeError):
+        raise QosInvalidCeilValue(ceil=value)
+
+
+def convert_to_burst(value):
+    try:
+        return convert_to_tc_not_zero_u32_or_none(value)
+    except (ValueError, TypeError):
+        raise QosInvalidBurstValue(burst=value)
+
+
+def convert_to_cburst(value):
+    try:
+        return convert_to_tc_not_zero_u32_or_none(value)
+    except (ValueError, TypeError):
+        raise QosInvalidCburstValue(cburst=value)
+
+
+def convert_to_filter_prio(value):
+    try:
+        value = convert_to_tc_u32(value)
+        if not value <= 65535:
+            raise ValueError
+        return value
+    except (ValueError, TypeError):
+        raise QosInvalidFilterPrioValue(prio=value)
+
+
+def convert_to_queue_prio(value):
+    try:
+        value = convert_to_tc_u32_or_none(value)
+        if not value <= 7:
+            raise ValueError
+        return value
+    except (ValueError, TypeError):
+        raise QosInvalidQueuePrioValue(prio=value)
+
+
+def convert_to_protocol(value):
+    if value is None:
+        ret = value
+    else:
+        try:
+            ret = int(value)
+            if not (ret >= 1 and ret <= 255):
+                raise ValueError
+        except (ValueError, TypeError):
+            raise QosInvalidProtocolValue(protocol=value)
+
+    return ret
+
+
+def convert_to_port(value):
+    if value is None:
+        ret = value
+    else:
+        try:
+            ret = int(value)
+            if not (ret >= 1 and ret <= 65535):
+                raise ValueError
+        except (ValueError, TypeError):
+            raise QosInvalidPortValue(port=value)
+
+    return ret
+
+
+RESOURCE_ATTRIBUTE_MAP = {
+    'qoss': {
+        'id': {'allow_post': False, 'allow_put': False,
+               'is_visible': True,
+               'validate': {'type:uuid': None},
+               'primary_key': True},
+        'tenant_id': {'allow_post': True, 'allow_put': False,
+                      'is_visible': True, 'required_by_policy': True,
+                      'validate': {'type:string': None}},
+        'name': {'allow_post': True, 'allow_put': True,
+                 'is_visible': True, 'default': '',
+                 'validate': {'type:string': None}},
+        'description': {'allow_post': True, 'allow_put': True,
+                        'is_visible': True, 'default': ''},
+        'direction': {'allow_post': True, 'allow_put': False,
+                      'is_visible': True,
+                      'validate': {'type:values': ['ingress', 'egress']}},
+        'target_type': {'allow_post': True, 'allow_put': True,
+                        'is_visible': True, 'default': None,
+                        'validate': {'type:values': [None, 'router', 'port']}},
+        'target_id': {'allow_post': True, 'allow_put': True,
+                      'is_visible': True, 'default': None,
+                      'validate': {'type:uuid_or_none': None}},
+        'rate': {'allow_post': True, 'allow_put': True,
+                 'is_visible': True,
+                 'convert_to': convert_to_rate},
+        'burst': {'allow_post': True, 'allow_put': True,
+                  'is_visible': True, 'default': None,
+                  'convert_to': convert_to_burst},
+        'cburst': {'allow_post': True, 'allow_put': True,
+                   'is_visible': True, 'default': None,
+                   'convert_to': convert_to_cburst},
+        'default_rate': {'allow_post': True, 'allow_put': True,
+                         'is_visible': True,
+                         'convert_to': convert_to_rate},
+        'default_burst': {'allow_post': True, 'allow_put': True,
+                          'is_visible': True, 'default': None,
+                          'convert_to': convert_to_burst},
+        'default_cburst': {'allow_post': True, 'allow_put': True,
+                           'is_visible': True, 'default': None,
+                           'convert_to': convert_to_cburst},
+        'default_queue_id': {'allow_post': False, 'allow_put': False,
+                             'is_visible': True},
+        'qos_queues': {'allow_post': False, 'allow_put': False,
+                       'is_visible': True},
+        'unattached_filters': {'allow_post': False, 'allow_put': False,
+                               'is_visible': True},
+    },
+    'qos_queues': {
+        'id': {'allow_post': False, 'allow_put': False,
+               'is_visible': True,
+               'validate': {'type:uuid': None},
+               'primary_key': True},
+        'tenant_id': {'allow_post': True, 'allow_put': False,
+                      'is_visible': True, 'required_by_policy': True,
+                      'validate': {'type:string': None}},
+        'qos_id': {'allow_post': True, 'allow_put': False,
+                   'is_visible': True, 'required_by_policy': True},
+        'parent_id': {'allow_post': True, 'allow_put': False,
+                      'is_visible': True, 'default': None,
+                      'validate': {'type:uuid_or_none': None}},
+        'prio': {'allow_post': True, 'allow_put': True,
+                 'is_visible': True, 'default': None,
+                 'convert_to': convert_to_queue_prio},
+        'rate': {'allow_post': True, 'allow_put': True,
+                 'is_visible': True,
+                 'convert_to': convert_to_rate},
+        'ceil': {'allow_post': True, 'allow_put': True,
+                 'is_visible': True, 'default': None,
+                 'convert_to': convert_to_ceil},
+        'burst': {'allow_post': True, 'allow_put': True,
+                  'is_visible': True, 'default': None,
+                  'convert_to': convert_to_burst},
+        'cburst': {'allow_post': True, 'allow_put': True,
+                   'is_visible': True, 'default': None,
+                   'convert_to': convert_to_cburst},
+        'subqueues': {'allow_post': False, 'allow_put': False,
+                      'is_visible': True},
+        'attached_filters': {'allow_post': False, 'allow_put': False,
+                             'is_visible': True},
+    },
+    'qos_filters': {
+        'id': {'allow_post': False, 'allow_put': False,
+               'is_visible': True,
+               'validate': {'type:uuid': None},
+               'primary_key': True},
+        'tenant_id': {'allow_post': True, 'allow_put': False,
+                      'is_visible': True, 'required_by_policy': True,
+                      'validate': {'type:string': None}},
+        'qos_id': {'allow_post': True, 'allow_put': False,
+                   'is_visible': True, 'required_by_policy': True},
+        'queue_id': {'allow_post': True, 'allow_put': True,
+                     'is_visible': True, 'default': None,
+                     'validate': {'type:uuid_or_none': None}},
+        'prio': {'allow_post': True, 'allow_put': True,
+                 'is_visible': True,
+                 'convert_to': convert_to_filter_prio},
+        'protocol': {'allow_post': True, 'allow_put': True,
+                     'is_visible': True, 'default': None,
+                     'convert_to': convert_to_protocol},
+        'src_port': {'allow_post': True, 'allow_put': True,
+                     'is_visible': True, 'default': None,
+                     'convert_to': convert_to_port},
+        'dst_port': {'allow_post': True, 'allow_put': True,
+                     'is_visible': True, 'default': None,
+                     'convert_to': convert_to_port},
+        'src_addr': {'allow_post': True, 'allow_put': True,
+                     'is_visible': True, 'default': None,
+                     'validate': {'type:subnet_or_none': None}},
+        'dst_addr': {'allow_post': True, 'allow_put': True,
+                     'is_visible': True, 'default': None,
+                     'validate': {'type:subnet_or_none': None}},
+        'custom_match': {'allow_post': True, 'allow_put': True,
+                         'is_visible': True, 'default': None,
+                         'validate': {'type:string_or_none': None}},
+        },
+}
+
+
+class Qos(extensions.ExtensionDescriptor):
+    """ Qos extension. """
+    @classmethod
+    def get_name(cls):
+        return "Eayun Neutron Qos"
+
+    @classmethod
+    def get_alias(cls):
+        return "qos"
+
+    @classmethod
+    def get_description(cls):
+        return "Eayun Neutron Qos extension."
+
+    @classmethod
+    def get_namespace(cls):
+        return "https://github.com/eayunstack"
+
+    @classmethod
+    def get_updated(cls):
+        return "2015-04-30T12:00:00-00:00"
+
+    @classmethod
+    def get_plugin_interface(cls):
+        return QosPluginBase
+
+    @classmethod
+    def get_resources(cls):
+        """Returns Ext Resources."""
+        plural_mappings = resource_helper.build_plural_mappings(
+            {}, RESOURCE_ATTRIBUTE_MAP)
+        attr.PLURALS.update(plural_mappings)
+        exts = []
+        plugin = manager.NeutronManager.get_service_plugins()['qos']
+        for resource_name in ['qos', 'qos_queue', 'qos_filter']:
+            collection_name = resource_name.replace('_', '-') + "s"
+            params = RESOURCE_ATTRIBUTE_MAP.get(resource_name + "s", dict())
+            controller = base.create_resource(collection_name,
+                                              resource_name,
+                                              plugin, params, allow_bulk=True,
+                                              allow_pagination=True,
+                                              allow_sorting=True)
+
+            ex = extensions.ResourceExtension(collection_name,
+                                              controller,
+                                              path_prefix=EAYUN_QOS,
+                                              attr_map=params)
+            exts.append(ex)
+
+        return exts
+
+    def update_attributes_map(self, attributes):
+        super(Qos, self).update_attributes_map(
+            attributes, extension_attrs_map=RESOURCE_ATTRIBUTE_MAP)
+
+    def get_extended_resources(self, version):
+        if version == "2.0":
+            return RESOURCE_ATTRIBUTE_MAP
+        else:
+            return {}
+
+
+@six.add_metaclass(abc.ABCMeta)
+class QosPluginBase(service_base.ServicePluginBase):
+
+    def get_plugin_name(self):
+        return 'qos'
+
+    def get_plugin_description(self):
+        return 'qos'
+
+    def get_plugin_type(self):
+        return 'qos'
+
+    @abc.abstractmethod
+    def create_qos(self, context, qos):
+        pass
+
+    @abc.abstractmethod
+    def update_qos(self, context, id, qos):
+        pass
+
+    @abc.abstractmethod
+    def delete_qos(self, context, id):
+        pass
+
+    @abc.abstractmethod
+    def get_qoss(self, context, filters=None, fields=None,
+                 sorts=None, limit=None, marker=None,
+                 page_reverse=False):
+        pass
+
+    @abc.abstractmethod
+    def get_qos(self, context, id, fields=None):
+        pass
+
+    @abc.abstractmethod
+    def create_qos_queue(self, context, qos_queue):
+        pass
+
+    @abc.abstractmethod
+    def update_qos_queue(self, context, id, qos_queue):
+        pass
+
+    @abc.abstractmethod
+    def delete_qos_queue(self, context, id):
+        pass
+
+    @abc.abstractmethod
+    def get_qos_queues(self, context, filters=None, fields=None,
+                       sorts=None, limit=None, marker=None,
+                       page_reverse=False):
+        pass
+
+    @abc.abstractmethod
+    def get_qos_queue(self, context, id, fields=None):
+        pass
+
+    @abc.abstractmethod
+    def create_qos_filter(self, context, qos_filter):
+        pass
+
+    @abc.abstractmethod
+    def update_qos_filter(self, context, id, qos_filter):
+        pass
+
+    @abc.abstractmethod
+    def delete_qos_filter(self, context, id):
+        pass
+
+    @abc.abstractmethod
+    def get_qos_filters(self, context, filters=None, fields=None,
+                        sorts=None, limit=None, marker=None,
+                        page_reverse=False):
+        pass
+
+    @abc.abstractmethod
+    def get_qos_filter(self, context, id, fields=None):
+        pass
diff --git a/neutron/services/qos/__init__.py b/neutron/services/qos/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/neutron/services/qos/agents/__init__.py b/neutron/services/qos/agents/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/neutron/services/qos/agents/qos_agent.py b/neutron/services/qos/agents/qos_agent.py
new file mode 100644
index 0000000..aebfdbd
--- /dev/null
+++ b/neutron/services/qos/agents/qos_agent.py
@@ -0,0 +1,602 @@
+# Copyright (c) 2015 Eayun, Inc.
+# All rights reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+import sys
+import uuid
+
+from oslo.config import cfg
+
+from neutron.api.rpc.agentnotifiers import qos_rpc_agent_api
+from neutron.agent.common import config
+from neutron.agent import rpc as agent_rpc
+from neutron.agent.linux import utils
+from neutron.common import config as common_config
+from neutron.common import topics
+from neutron.openstack.common import service
+from neutron.openstack.common import log as logging
+from neutron.openstack.common import loopingcall
+from neutron.openstack.common import periodic_task
+from neutron import service as neutron_service
+from neutron import context
+from neutron import manager
+
+LOG = logging.getLogger(__name__)
+
+# Qos Info Dictionary:
+# Qos:
+# {
+#     'id': {
+#         'target_type': xxx,
+#         'target_id': xxx,
+#         'devices': [],
+#         'rate': xxx,
+#         'burst': xxx,
+#         'cburst': xxx,
+#         'default_queue_id': xxx
+#         'queues': [xxx, ...]
+#         'registered_classes': {
+#             '1':  'me'
+#             'fffe': 'default_queue_id'
+#             'class1': 'queue_id1'
+#         },
+#     },
+#     'id2': {
+#     },
+# }
+# Queue:
+# {
+#     'id': {
+#         'qos_id': xxx,
+#         'class': xxx,
+#         'parent_id': xxx,
+#         'prio': xxx,
+#         'rate': xxx,
+#         'ceil' xxx,
+#         'burst': xxx,
+#         'cburst': xxx,
+#         'subqueues': [xxx, ...],
+#         'filters': [xxx, ...],
+#     },
+#     'id2': {
+#     },
+# }
+# Filter:
+# {
+#     'id': {
+#         'qos_id': xxx,
+#         'queue_id': xxx,
+#         'prio': xxx,
+#         'protocol': xxx,
+#         'src_port' xxx,
+#         'dst_port': xxx,
+#         'src_addr': xxx,
+#         'dst_addr': xxx,
+#         'custom_match': xxx,
+#     },
+#     'id2': {
+#     },
+# }
+
+
+class QosAgent(qos_rpc_agent_api.QosPluginRpc, manager.Manager):
+
+    Opts = [
+        cfg.IntOpt('report_interval', default=300,
+                   help=_("Interval between two qos reports")),
+    ]
+
+    def __init__(self, host, conf=None):
+        self.conf = conf or cfg.CONF
+        self.context = context.get_admin_context_without_session()
+        self.host = host
+        self.qos_info = {'qos': {}, 'queue': {}, 'filter': {}}
+        self.root_helper = config.get_root_helper(self.conf)
+        super(QosAgent, self).__init__(host=host)
+
+    def _run_tc(self, cmd, namespace=''):
+        if namespace:
+            cmd = ['ip', 'netns', 'exec', namespace] + cmd
+        return utils.execute(cmd, root_helper=self.root_helper,
+                             check_exit_code=False)
+
+    def _tc_add_qos(self, qos_id):
+        qos = self.qos_info['qos'][qos_id]
+
+        if qos['target_type'] == 'router':
+            namespace = ("qrouter-%s" % qos['target_id'])
+        else:
+            namespace = ''
+
+        rate = ("%sbps" % qos['rate'])
+        ceil = ("%sbps" % qos['rate'])
+        for device in qos['devices']:
+            # delete the existing one in case of agent has restarted
+            del_qdisc = [
+                'tc', 'qdisc', 'del', 'dev', device,
+                'root', 'handle', '1:', 'htb'
+            ]
+            self._run_tc(del_qdisc, namespace)
+
+            add_qdisc = [
+                'tc', 'qdisc', 'replace', 'dev', device,
+                'root', 'handle', '1:', 'htb', 'default', 'fffe'
+            ]
+            add_class = [
+                'tc', 'class', 'replace', 'dev', device,
+                'parent', '1:0', 'classid', '1:1', 'htb',
+                'rate', rate, 'ceil', ceil
+            ]
+            if qos['burst']:
+                add_class.extend(['burst', qos['burst']])
+            if qos['cburst']:
+                add_class.extend(['cburst', qos['cburst']])
+
+            self._run_tc(add_qdisc, namespace)
+            self._run_tc(add_class, namespace)
+
+    def _tc_update_qos(self, qos_id):
+        qos = self.qos_info['qos'][qos_id]
+
+        if qos['target_type'] == 'router':
+            namespace = ("qrouter-%s" % qos['target_id'])
+        else:
+            namespace = ''
+
+        rate = ("%sbps" % qos['rate'])
+        ceil = ("%sbps" % qos['rate'])
+        for device in qos['devices']:
+            change_class = [
+                'tc', 'class', 'change', 'dev', device,
+                'parent', '1:0', 'classid', '1:1', 'htb',
+                'rate', rate, 'ceil', ceil
+            ]
+            if qos['burst']:
+                change_class.extend(['burst', qos['burst']])
+            if qos['cburst']:
+                change_class.extend(['cburst', qos['cburst']])
+
+            self._run_tc(change_class, namespace)
+
+    def _tc_delete_qos(self, qos_id):
+        qos = self.qos_info['qos'][qos_id]
+
+        if qos['target_type'] == 'router':
+            namespace = ("qrouter-%s" % qos['target_id'])
+        else:
+            namespace = ''
+
+        for device in qos['devices']:
+            del_qdisc = [
+                'tc', 'qdisc', 'del', 'dev', device,
+                'root', 'handle', '1:', 'htb'
+            ]
+            self._run_tc(del_qdisc, namespace)
+
+    def _tc_add_queue(self, queue_id):
+        queue = self.qos_info['queue'][queue_id]
+        qos = self.qos_info['qos'][queue['qos_id']]
+
+        if qos['target_type'] == 'router':
+            namespace = ("qrouter-%s" % qos['target_id'])
+        else:
+            namespace = ''
+
+        if queue['parent_id']:
+            parent_class = self.qos_info['queue'][queue['parent_id']]['class']
+        else:
+            parent_class = 1
+        parent_id = "1:%s" % parent_class
+        class_id = "1:%s" % queue['class']
+        rate = ("%sbps" % queue['rate'])
+        for device in qos['devices']:
+            add_class = [
+                'tc', 'class', 'replace', 'dev', device,
+                'parent', parent_id, 'classid', class_id, 'htb',
+                'rate', rate
+            ]
+            if queue['prio']:
+                add_class.extend(['prio', queue['prio']])
+            if queue['ceil']:
+                ceil = ("%sbps" % queue['ceil'])
+                add_class.extend(['ceil', ceil])
+            if queue['burst']:
+                add_class.extend(['burst', queue['burst']])
+            if queue['cburst']:
+                add_class.extend(['cburst', queue['cburst']])
+
+            self._run_tc(add_class, namespace)
+
+    def _tc_update_queue(self, queue_id):
+        queue = self.qos_info['queue'][queue_id]
+        qos = self.qos_info['qos'][queue['qos_id']]
+
+        if qos['target_type'] == 'router':
+            namespace = ("qrouter-%s" % qos['target_id'])
+        else:
+            namespace = ''
+
+        if queue['parent_id']:
+            parent_class = self.qos_info['queue'][queue['parent_id']]['class']
+        else:
+            parent_class = 1
+        parent_id = "1:%s" % parent_class
+        class_id = "1:%s" % queue['class']
+        rate = ("%sbps" % queue['rate'])
+        for device in qos['devices']:
+            change_class = [
+                'tc', 'class', 'change', 'dev', device,
+                'parent', parent_id, 'classid', class_id, 'htb',
+                'rate', rate
+            ]
+            if queue['prio']:
+                change_class.extend(['prio', queue['prio']])
+            if queue['ceil']:
+                ceil = ("%sbps" % queue['ceil'])
+                change_class.extend(['ceil', ceil])
+            if queue['burst']:
+                change_class.extend(['burst', queue['burst']])
+            if queue['cburst']:
+                change_class.extend(['cburst', queue['cburst']])
+
+            self._run_tc(change_class, namespace)
+
+    def _tc_delete_queue(self, queue_id):
+        queue = self.qos_info['queue'][queue_id]
+        qos = self.qos_info['qos'][queue['qos_id']]
+
+        if qos['target_type'] == 'router':
+            namespace = ("qrouter-%s" % qos['target_id'])
+        else:
+            namespace = ''
+
+        if queue['parent_id']:
+            parent_class = self.qos_info['queue'][queue['parent_id']]['class']
+        else:
+            parent_class = 1
+        parent_id = "1:%s" % parent_class
+        class_id = "1:%s" % queue['class']
+        for device in qos['devices']:
+            delete_class = [
+                'tc', 'class', 'del', 'dev', device,
+                'parent', parent_id, 'classid', class_id
+            ]
+            self._run_tc(delete_class, namespace)
+
+    def _tc_add_filter(self, filter_id):
+        qf = self.qos_info['filter'][filter_id]
+        qos = self.qos_info['qos'][qf['qos_id']]
+
+        if qos['target_type'] == 'router':
+            namespace = ("qrouter-%s" % qos['target_id'])
+        else:
+            namespace = ''
+
+        flowid = "1:%s" % self.qos_info['queue'][qf['queue_id']]['class']
+        for device in qos['devices']:
+            add_filter = [
+               'tc', 'filter', 'add', 'dev', device,
+               'protocol', 'ip', 'parent', '1:0', 'prio', qf['prio']
+            ]
+            selector = []
+            selector.extend(['u32'])
+            if qf['protocol']:
+                selector.extend([
+                    'match', 'ip', 'protocol', qf['protocol'], '0xff'
+                ])
+            if qf['src_port']:
+                selector.extend([
+                    'match', 'ip', 'sport', qf['src_port'], '0xffff'
+                ])
+            if qf['dst_port']:
+                selector.extend([
+                    'match', 'ip', 'dport', qf['dst_port'], '0xffff'
+                ])
+            if qf['src_addr']:
+                selector.extend([
+                    'match', 'ip', 'src', qf['src_addr']
+                ])
+            if qf['dst_addr']:
+                selector.extend([
+                    'match', 'ip', 'dst', qf['dst_addr']
+                ])
+            if len(selector) > 1:
+                add_filter.extend(selector)
+            add_filter.extend(['flowid', flowid])
+
+            self._run_tc(add_filter, namespace)
+
+    def _tc_delete_filter(self, filter_id):
+        qf = self.qos_info['filter'][filter_id]
+        qos = self.qos_info['qos'][qf['qos_id']]
+
+        if qos['target_type'] == 'router':
+            namespace = ("qrouter-%s" % qos['target_id'])
+        else:
+            namespace = ''
+
+        for device in qos['devices']:
+            del_filter = [
+               'tc', 'filter', 'del', 'dev', device,
+               'protocol', 'ip', 'parent', '1:0', 'prio', qf['prio']
+            ]
+            self._run_tc(del_filter, namespace)
+
+    # Here start the deletion part
+    def _remove_queue_from_qos(self, queue_id):
+        queue = self.qos_info['queue'][queue_id]
+        qos_id = queue['qos_id']
+        registered_class = queue['class']
+
+        qos = self.qos_info['qos'][qos_id]
+        qos['queues'].remove(queue_id)
+        qos['registered_classes'].pop(registered_class)
+
+    def _remove_subqueue_from_queue(self, subqueue_id):
+        subqueue = self.qos_info['queue'][subqueue_id]
+        parent_queue_id = subqueue['parent_id']
+        parent_queue = self.qos_info['queue'][parent_queue_id]
+        parent_queue['subqueues'].remove(subqueue_id)
+
+    def _remove_filter_from_queue(self, filter_id):
+        queue_id = self.qos_info['filter'][filter_id]['queue_id']
+        self.qos_info['queue'][queue_id]['filters'].remove(filter_id)
+
+    def _delete_qos(self, qos_id, info_only=False):
+        if not info_only:
+            self._tc_delete_qos(qos_id)
+        for queue_id in self.qos_info['qos'][qos_id]['queues']:
+            self._delete_queue(queue_id, info_only=True)
+        del self.qos_info['qos'][qos_id]
+
+    def _delete_queue(self, queue_id, info_only=False):
+        for filter_id in self.qos_info['queue'][queue_id]['filters']:
+            self._delete_filter(filter_id, info_only=info_only)
+        for subqueue_id in self.qos_info['queue'][queue_id]['subqueues']:
+            self._delete_queue(subqueue_id, info_only=info_only)
+        if not info_only:
+            self._tc_delete_queue(queue_id)
+        if self.qos_info['queue'][queue_id]['parent_id']:
+            self._remove_subqueue_from_queue(queue_id)
+        self._remove_queue_from_qos(queue_id)
+        del self.qos_info['queue'][queue_id]
+
+    def _delete_filter(self, filter_id, info_only=False):
+        self._remove_filter_from_queue(filter_id)
+        if not info_only:
+            self._tc_delete_filter(filter_id)
+        del self.qos_info['filter'][filter_id]
+
+    # Here start the addition part
+    def _add_queue_to_qos(self, queue_id):
+        queue = self.qos_info['queue'][queue_id]
+        qos_id = queue['qos_id']
+
+        qos = self.qos_info['qos'][qos_id]
+        qos['queues'].append(queue_id)
+
+        if qos['default_queue_id'] == queue_id:
+            class_id = 'fffe'
+        else:
+            class_id = queue_id[:4]
+            while class_id in qos['registered_classes']:
+                class_id = str(uuid.uuid4())[:4]
+            qos['registered_classes'].update({class_id: queue_id})
+
+        queue.update({'class': class_id})
+
+    def _add_subqueue_to_parent(self, subqueue_id):
+        subqueue = self.qos_info['queue'][subqueue_id]
+        parent_queue_id = subqueue['parent_id']
+        if parent_queue_id:
+            parent_queue = self.qos_info['queue'][parent_queue_id]
+            parent_queue['subqueues'].append(subqueue_id)
+
+    def _add_filter_to_queue(self, filter_id):
+        queue_id = self.qos_info['filter'][filter_id]['queue_id']
+        queue = self.qos_info['queue'][queue_id]
+        queue['filters'].append(filter_id)
+
+    def _add_qos(self, qos):
+        qos_id = qos['id']
+        added_qos = {
+            'target_type': qos['target_type'],
+            'target_id': qos['target_id'],
+            'devices': qos['devices'],
+            'rate': qos['rate'],
+            'burst': qos['burst'],
+            'cburst': qos['cburst'],
+            'default_queue_id': qos['default_queue_id'],
+            'queues': [],
+            'registered_classes': {
+                '0001': 'myself',
+                'fffe': qos['default_queue_id'],
+            },
+        }
+        self.qos_info['qos'][qos_id] = added_qos
+        self._tc_add_qos(qos_id)
+        for queue in qos['qos_queues']:
+            self._add_queue(queue)
+
+    def _add_queue(self, queue):
+        queue_id = queue['id']
+        added_queue = {
+            'qos_id': queue['qos_id'],
+            'class': None,  # class should be updated when add to qos
+            'parent_id': queue['parent_id'],
+            'prio': queue['prio'],
+            'rate': queue['rate'],
+            'ceil': queue['ceil'],
+            'burst': queue['burst'],
+            'cburst': queue['cburst'],
+            'subqueues': [],
+            'filters': [],
+        }
+        self.qos_info['queue'][queue_id] = added_queue
+        self._add_queue_to_qos(queue_id)
+        self._add_subqueue_to_parent(queue_id)
+        self._tc_add_queue(queue_id)
+        for subqueue in queue['subqueues']:
+            self._add_queue(subqueue)
+        for qos_filter in queue['attached_filters']:
+            self._add_filter(qos_filter)
+
+    def _add_filter(self, qos_filter):
+        qf_id = qos_filter['id']
+        qf = {
+            'qos_id': qos_filter['qos_id'],
+            'queue_id': qos_filter['queue_id'],
+            'prio': qos_filter['prio'],
+            'protocol': qos_filter['protocol'],
+            'src_port': qos_filter['src_port'],
+            'dst_port': qos_filter['dst_port'],
+            'src_addr': qos_filter['src_addr'],
+            'dst_addr': qos_filter['dst_addr'],
+            'custom_match': qos_filter.get('custom_match', None),
+        }
+        self.qos_info['filter'][qf_id] = qf
+        self._tc_add_filter(qf_id)
+        self._add_filter_to_queue(qf_id)
+
+    # Here start the update part
+    def _update_qos(self, qos):
+        qos_id = qos['id']
+        if qos_id not in self.qos_info['qos']:
+            self._add_qos(qos)
+        elif self.qos_info['qos'][qos_id]['devices'] == qos['devices']:
+            updated_qos = {
+                'rate': qos['rate'],
+                'burst': qos['burst'],
+                'cburst': qos['cburst'],
+            }
+            self.qos_info['qos'][qos_id].update(updated_qos)
+            self._tc_update_qos(qos_id)
+            for queue in qos['qos_queues']:
+                if queue['id'] == qos['default_queue_id']:
+                    self._update_queue(queue)
+        else:
+            self._delete_qos(qos_id)
+            self._add_qos(qos)
+
+    def _update_queue(self, queue):
+        queue_id = queue['id']
+        updated_queue = {
+            'prio': queue['prio'],
+            'rate': queue['rate'],
+            'ceil': queue['ceil'],
+            'burst': queue['burst'],
+            'cburst': queue['cburst'],
+        }
+        self.qos_info['queue'][queue_id].update(updated_queue)
+        self._tc_update_queue(queue_id)
+
+    def _update_filter(self, qos_filter):
+        # filter has no class/handle for "tc change"
+        self._delete_filter(qos_filter['id'])
+        self._add_filter(qos_filter)
+
+    @periodic_task.periodic_task(run_immediately=True)
+    def _sync_qos_task(self, context):
+        qos = self._sync_qos(context, self.qos_info['qos'].keys())
+        for deleted_qos in qos['deleted']:
+            self._delete_qos(deleted_qos, info_only=True)
+        for added_qos in qos['added']:
+            self._add_qos(added_qos)
+
+    def qos_created(self, context, payload):
+        self._add_qos(payload)
+
+    def qos_updated(self, context, payload):
+        self._update_qos(payload)
+
+    def qos_moved(self, context, payload):
+        self._delete_qos(payload)
+
+    def qos_deleted(self, context, payload):
+        self._delete_qos(payload)
+
+    def qos_queue_created(self, context, payload):
+        self._add_queue(payload)
+
+    def qos_queue_updated(self, context, payload):
+        self._update_queue(payload)
+
+    def qos_queue_deleted(self, context, payload):
+        self._delete_queue(payload)
+
+    def qos_filter_created(self, context, payload):
+        self._add_filter(payload)
+
+    def qos_filter_updated(self, context, payload):
+        self._update_filter(payload)
+
+    def qos_filter_deleted(self, context, payload):
+        self._delete_filter(payload)
+
+
+class QosAgentWithStateReport(QosAgent):
+
+    def __init__(self, host, conf=None):
+        super(QosAgentWithStateReport, self).__init__(
+            host=host, conf=conf)
+        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)
+        self.agent_state = {
+            'binary': 'neutron-qos-agent',
+            'host': host,
+            'topic': qos_rpc_agent_api.QOS_AGENT,
+            'configurations': {
+                'report_interval': self.conf.report_interval,
+            },
+            'start_flag': True,
+            'agent_type': 'Qos agent',
+        }
+        report_interval = cfg.CONF.AGENT.report_interval
+        self.use_call = True
+        if report_interval:
+            self.heartbeat = loopingcall.FixedIntervalLoopingCall(
+                self._report_state)
+            self.heartbeat.start(interval=report_interval)
+
+    def _report_state(self):
+        try:
+            self.state_rpc.report_state(self.context, self.agent_state,
+                                        self.use_call)
+            self.agent_state.pop('start_flag', None)
+            self.use_call = False
+        except AttributeError:
+            # This means the server does not support report_state
+            LOG.warn("Neutron server does not support state report."
+                     " State report for this agent will be disabled.")
+            self.heartbeat.stop()
+            return
+        except Exception:
+            LOG.exception("Failed reporting state!")
+
+    def agent_updated(self, context, payload):
+        LOG.info("agent_updated by server side %s!", payload)
+
+
+def main():
+    conf = cfg.CONF
+    conf.register_opts(QosAgent.Opts)
+    config.register_agent_state_opts_helper(conf)
+    config.register_root_helper(conf)
+    common_config.init(sys.argv[1:])
+    config.setup_logging()
+    server = neutron_service.Service.create(
+        binary='neutron-qos-agent',
+        topic=qos_rpc_agent_api.QOS_AGENT,
+        manager='neutron.services.qos.agents.'
+                'qos_agent.QosAgentWithStateReport')
+    service.launch(server).wait()
diff --git a/neutron/services/qos/qos_plugin.py b/neutron/services/qos/qos_plugin.py
new file mode 100644
index 0000000..4e72306
--- /dev/null
+++ b/neutron/services/qos/qos_plugin.py
@@ -0,0 +1,37 @@
+# Copyright (c) 2015 Eayun, Inc.
+# All rights reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+from neutron.api.rpc.agentnotifiers import qos_rpc_agent_api
+from neutron.common import rpc as n_rpc
+from neutron.db.qos import qos_rpc
+from neutron.db import portbindings_db
+
+
+class QosPlugin(qos_rpc.QosServerRpcServerMixin,
+                portbindings_db.PortBindingMixin):
+
+    supported_extension_aliases = ['qos']
+
+    def __init__(self):
+        super(QosPlugin, self).__init__()
+
+        self.endpoints = [qos_rpc.QosRpcCallbacks(self)]
+
+        self.conn = n_rpc.create_connection(new=True)
+        self.conn.create_consumer(
+            qos_rpc_agent_api.QOS_PLUGIN, self.endpoints, fanout=False)
+        self.conn.consume_in_threads()
+
+        self.notifier = qos_rpc_agent_api.QosAgentNotifyAPI()
diff --git a/setup.cfg b/setup.cfg
index 5793ad0..880b8ef 100644
--- a/setup.cfg
+++ b/setup.cfg
@@ -44,6 +44,7 @@ data_files =
	etc/neutron/rootwrap.d/linuxbridge-plugin.filters
	etc/neutron/rootwrap.d/nec-plugin.filters
	etc/neutron/rootwrap.d/openvswitch-plugin.filters
+	etc/neutron/rootwrap.d/qos.filters
	etc/neutron/rootwrap.d/ryu-plugin.filters
	etc/neutron/rootwrap.d/vpnaas.filters
	etc/init.d = etc/init.d/neutron-server
@@ -117,6 +118,7 @@ console_scripts =
	neutron-nvsd-agent = neutron.plugins.oneconvergence.agent.nvsd_neutron_agent:main
	neutron-openvswitch-agent = neutron.plugins.openvswitch.agent.ovs_neutron_agent:main
	neutron-ovs-cleanup = neutron.agent.ovs_cleanup_util:main
+	neutron-qos-agent = neutron.services.qos.agents.qos_agent:main
	neutron-restproxy-agent = neutron.plugins.bigswitch.agent.restproxy_agent:main
	neutron-ryu-agent = neutron.plugins.ryu.agent.ryu_neutron_agent:main
	neutron-server = neutron.server:main
-- 
2.4.2

